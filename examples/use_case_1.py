import os, sys
sys.path.append(os.path.dirname(sys.path[0]))

from hw2vec.hw2graph import *

from optparse import OptionParser
import shutil 
from glob import glob
from pathlib import Path
from pprint import pprint
import networkx as nx
from torch_geometric.utils.convert import from_networkx
from matplotlib import pylab
import matplotlib.pyplot as plt

global_type2idx = {
    'concat':0, 
    'input':1, 
    'unand':2, 
    'unor':3, 
    'uxor':4, 
    'signal':5, 
    'uand':6, 
    'ulnot':7,
    'uxnor':8,
    'numeric':9,
    'partselect':10,
    'and':11,
    'unot':12,
    'branch':13,
    'or':14,
    'uor':15,
    'output':16
}

more_type = set()

def save_graph(nxgraph, file_name):
    plt.figure(num=None, figsize=(60, 60), dpi=80)
    plt.axis('off')
    fig = plt.figure(1)

    pos = nx.nx_pydot.graphviz_layout(nxgraph, prog="dot")
    nx.draw_networkx_nodes(nxgraph, pos, with_labels=False)
    nx.draw_networkx_edges(nxgraph, pos)
    labels = {}    
    for node in nxgraph.nodes(data=True):
        labels[node[0]] = node[1]['label']
    nx.draw_networkx_labels(nxgraph, pos, labels)
    plt.savefig(file_name, bbox_inches="tight")
    pylab.close()
    del fig

def parse_single_verilog_code(verilog_path, output_path, graph_format="DFG"):
    # Initialize a generator, can choose different generator based on graph_format: DFG, AST 
    if graph_format == "DFG":
        graph_generator = DFGgenerator(str(verilog_path), str(output_path))
    elif graph_format == "AST":
        graph_generator = ASTgenerator(str(verilog_path), str(output_path))
    
    graph_generator.process()

    # Put graph information into a dictionary called ‘graph_json’.
    graph_json = graph_generator.get_graph_json()
    pprint(graph_json)

    '''
        Normalize node labels: numerical value, signal, input, concat, unand, unor, ... 
    '''
    NORMALIZE = True # this allows users to choose whether they want normalization or not.
    
    if not NORMALIZE:
        node_labels = set()
        for src in graph_json['edge_index']:
            node_name = src
            if '_graphrename' in src:
                node_name = src[:src.index('_graphrename')]
            
            if '.' in node_name: 
                type_of_node = node_name.split('.')[-1]
            elif '_' in node_name:
                type_of_node = node_name.split('_')[-1]
            else:
                type_of_node = node_name.lower()

            node_labels.add(type_of_node)
        label2idx = {v:k for k, v in enumerate(list(node_labels))}

    '''
        Convert the graph to networkx object then to torch_geometric Data instance to get A and X used in graph learning. 
    '''

    hardware_graph = nx.DiGraph() 
    # https://pytorch-geometric.readthedocs.io/en/latest/_modules/torch_geometric/utils/convert.html
    # Agraph generated by graphGenerator is not accepted in pytorch-geometric
    for src in graph_json['edge_index']:
        node_name = src
        if '_graphrename' in src:
            node_name = src[:src.index('_graphrename')]
        
        if NORMALIZE:
            if '\'d' in node_name or '\'b' in node_name or '\'o' in node_name or '\'h' in node_name:
                type_of_node = "numeric"
            elif graph_generator.verilog_parser.dfg_graph_generator.graph.in_degree(src) == 0:
                type_of_node = "output"
            elif len(graph_generator.verilog_parser.dfg_graph_generator.graph.successors(src)) == 0:
                type_of_node = "input"
            elif '.' in node_name or '_' in node_name:
                type_of_node = "signal"
            else:
                type_of_node = node_name.lower()
            if type_of_node not in global_type2idx:
                # raise Exception("The operation is not in the global_type2idx table, please report the error to" +   
                #                 "https://github.com/louisccc/hw2vec/issues")
                print("----------------"+type_of_node+"--------------")
                more_type.add(type_of_node)
            else:
                hardware_graph.add_node(src, x=global_type2idx[type_of_node], label=type_of_node)
        else: 
            if '.' in node_name: 
                type_of_node = node_name.split('.')[-1]
            elif '_' in node_name:
                type_of_node = node_name.split('_')[-1]
            else:
                type_of_node = node_name.lower()
            hardware_graph.add_node(src, x=label2idx[type_of_node], label=type_of_node) 

        for neighbor in graph_json['edge_index'][src]:
            dst = neighbor[1]
            hardware_graph.add_edge(src, dst)
    
    data = from_networkx(hardware_graph)
    print(data.x) # demo the X 
    print(data.edge_index) # demo the edge_index

    # Draw the graph with labels.
    save_graph(hardware_graph, "hardware_design_output.png")

def parse_multiple_verilog_code(dataset_directory, output_path, graph_format="DFG"):
    for verilog_path in glob("%s/**/topModule.v" % str(dataset_directory), recursive=True):
        parse_single_verilog_code(verilog_path, output_path, graph_format="DFG")


if __name__ == '__main__':
    ''' 
        An example on how to genreate the data flow graph for a dataset of Verilog harwdare designs
        USAGE:  python graph_generation_example.py 
    '''    
    verilog_path = Path('../tests/data/IP-dataset/Verilog/C432/c432/topModule.v')
    dataset_directory = Path('../tests/data/IP-dataset/Verilog/C1908').resolve()
    dataset_output_dir_path = Path('./').resolve()
    
    # example 1: parse a single verilog code and visualize.
    parse_single_verilog_code(verilog_path, dataset_output_dir_path, graph_format="DFG")
    
    # example 2: parse a batch of verilog code and package.
    # parse_multiple_verilog_code(dataset_directory, dataset_output_dir_path, graph_format="DFG")
    # print(more_type)