import os, sys
sys.path.append(os.path.dirname(sys.path[0]))

from hw2vec.hw2graph import *

from optparse import OptionParser
import shutil 
from glob import glob
from pathlib import Path
from pprint import pprint
import networkx as nx
from torch_geometric.utils.convert import from_networkx
from matplotlib import pylab
import matplotlib.pyplot as plt

global_type2idx = {
    'concat':0, 
    'input':1, 
    'unand':2, 
    'unor':3, 
    'uxor':4, 
    'signal':5, 
    'uand':6, 
    'ulnot':7
}

def save_graph(nxgraph, file_name):
    plt.figure(num=None, figsize=(60, 60), dpi=80)
    plt.axis('off')
    fig = plt.figure(1)

    pos = nx.nx_pydot.graphviz_layout(nxgraph, prog="dot")
    nx.draw_networkx_nodes(nxgraph, pos, with_labels=False)
    nx.draw_networkx_edges(nxgraph, pos)
    labels = {}    
    for node in nxgraph.nodes(data=True):
        labels[node[0]] = node[1]['label']
    nx.draw_networkx_labels(nxgraph, pos, labels)
    plt.savefig(file_name, bbox_inches="tight")
    pylab.close()
    del fig

def parse_single_verilog_code(verilog_path, output_path, graph_format="DFG"):
    ''' 
        handling a single verilog code to a DFG. 

        Parse_single_verilog_code: hardware code → graph → A and X 
    '''

    # Initialize a generator.
    # Choose different generator based on graph_format: DFG, CFG, AST 
    if graph_format == "DFG":
        graph_generator = RTLDFGGenerator()
    elif graph_format == "CFG":
        graph_generator = RTLCFGGenerator()
    elif graph_format == "AST":
        graph_generator = RTLASTGenerator()
    
    # generator parses the code and generates a graph
    graph = graph_generator.process(verilog_path, output_path) 

    # Put graph information into a dictionary called ‘graph_json’, which contains:
    # Nodes, edges, edge_index, root_nodes
    graph_json = graph_generator.get_graph_json(graph.graph_generator)
    pprint(graph_json['nodes'])
    pprint(graph_json['edges'])
    pprint(graph_json['edge_index'])
    pprint(graph_json['root_nodes'])

    # Export ‘graph_json’ to a json file.
    graph_generator.export_json(graph_json, output_path)
    # Draw the graph.
    graph_generator.draw(graph.graph_generator)
   

    '''
        Normalize node labels: numerical value, signal, input, concat, unand, unor, ... 
    '''
    NORMALIZE=False
    # this allows users to choose whether they want normalization or not.
    
    if not NORMALIZE:
        node_labels = set()
        for src in graph_json['edge_index']:
            node_name = src
            if '_graphrename' in src:
                node_name = src[:src.index('_graphrename')]
            
            if '.' in node_name: 
                type_of_node = node_name.split('.')[-1]
            elif '_' in node_name:
                type_of_node = node_name.split('_')[-1]
            else:
                type_of_node = node_name.lower()

            node_labels.add(type_of_node)
        label2idx = {v:k for k, v in enumerate(list(node_labels))}


    '''
        Convert the graph to networkx object then to torch_geometric Data instance to get A and X used in graph learning. 
    ''' 
    hardware_graph = nx.DiGraph() 
    # https://pytorch-geometric.readthedocs.io/en/latest/_modules/torch_geometric/utils/convert.html
    # Agraph generated by graphGenerator is not accepted in pytorch-geometric
    for src in graph_json['edge_index']:
        node_name = src
        if '_graphrename' in src:
            node_name = src[:src.index('_graphrename')]
        
        if NORMALIZE:
            if '.' in node_name: 
                type_of_node = "signal"
            elif '_' in node_name:
                type_of_node = "input"
            else:
                type_of_node = node_name.lower()       
            hardware_graph.add_node(src, x=global_type2idx[type_of_node], label=type_of_node)
        else: 
            if '.' in node_name: 
                type_of_node = node_name.split('.')[-1]
            elif '_' in node_name:
                type_of_node = node_name.split('_')[-1]
            else:
                type_of_node = node_name.lower()
            hardware_graph.add_node(src, x=label2idx[type_of_node], label=type_of_node) 

        for neighbor in graph_json['edge_index'][src]:
            dst = neighbor[1]
            hardware_graph.add_edge(src, dst)
    
    data = from_networkx(hardware_graph)
    print(data.x) # demo the X 
    print(data.edge_index) # demo the edge_index

    # Draw the graph with labels.
    save_graph(hardware_graph, "hardware_design_output.png")
    
    # X = F.one_hot(data.x, num_classes=len(label2idx)).float() ## one-hot encoding should be done in the training pipeline!


def parse_multiple_verilog_code(verilog_path, output_path, graph_format="DFG"):
    # handling verilog code in batch to DFGs.
    # graphs = hw2graph_dfg.process_batch(dataset_directory, "topModule.v")
    # dfg_generator = HW2Graph(graph_format="DFG", code_language="verilog", top_module='top')
    # json_graphs = dfg_generator.process_batch(dataset_directory)
    # dfg_generator.export_jsons(json_graphs, output_dir=dataset_output_dir_path)
    
    # for verilog_path in glob("%s/**/topModule.v" % str(dataset_directory), recursive=True):
    #     print(verilog_path)
    #     # import pdb;pdb.set_trace()
    #     try:
    #         graph_generator = RTLDFGGenerator(verilog_path, "./", code_language='verilog', top_module='top', draw_graph=False)
    #         # Export the list of nodes 
    #         print('export the graph as a JSON dictionary: ')
    #         graph_generator.export_nodes()
    #         # Export the list of root nodes
    #         graph_generator.export_root_nodes()
    #         # Export the list of edges
    #         graph_generator.export_edges()
    #         # Draw Data Flow Graph
    #         graph_generator.draw_DFG()
    #         # Draw the subgraphs ( data flow graph of signals)
    #         graph_generator.draw_signals_DFG()
    #     except:
    #         print('Error in', verilog_path)
    pass


if __name__ == '__main__':
    ''' 
        An example on how to genreate the data flow graph for a dataset of Verilog harwdare designs
        USAGE:  python graph_generation_example.py 
    '''    
    verilog_path = Path('../tests/data/IP-dataset/Verilog/C432/c432/topModule.v')
    dataset_directory = Path('../tests/data/IP-dataset/Verilog/C432').resolve()
    dataset_output_dir_path = Path('./').resolve()
    
    # example 1: parse a single verilog code and visualize.
    parse_single_verilog_code(verilog_path, dataset_output_dir_path, graph_format="DFG")
    
    # example 2: parse a batch of verilog code and package.
    parse_multiple_verilog_code(verilog_path, dataset_output_dir_path, graph_format="DFG")